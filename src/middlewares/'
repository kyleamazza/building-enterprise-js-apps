import { expect } from 'chai';
import { spy, stub } from 'sinon';
import cloneDeep from 'lodash.clonedeep';

import checkEmptyPayload from '.';

describe('checkEmptyPayload', function () {
  let req; 
  let res; 
  let next;
  describe('When req.method is not one of POST, PATCH, or PUT', function () {
    let clonedRes;

    beforeEach(function () {
      req = { method: 'GET' };
      res = {};
      next = spy();
      clonedRes = cloneDeep(res);
      checkEmptyPayload(req, res, next);
    });

    it('should not modify `res`', function () {
      expect(res).to.be.eql(clonedRes);
    });

    it('should call next() once', function () {
      expect(next.calledOnce).to.be.true;
    });

    afterEach(function () {
      req = undefined;
      res = undefined;
      next = undefined;
    });
  });

  (['POST', 'PATCH', 'PUT']).forEach((method) => {
    describe(`When req.method is ${method}`, function () {
      describe('and the "Content-Length" header is not equal to "0"', function () {
        let clonedRes;

        beforeEach(function () {
          req = {
            method,
            headers: { 'content-length': '1' }
          };
          res = {
            status: spy(),
            set: spy(),
            json: spy()
          };
          next = spy();
          clonedRes = cloneDeep(res);

          checkEmptyPayload(req, res, next);
        });

        it('should not modify res', function () {
          console.log(res);
          expect(res).to.be.eql(clonedRes);
        });

        it('should call next() once', function () {
          expect(next.calledOnce).to.be.true;
        });
      });

      describe('and the "Content-Length" header is equal to "0"', function () {
        let returnValue;
        let expectedReturnValue;

        beforeEach(function () {
          req = {
            method,
            headers: { 'content-length': '0' }
          };

          res = {
            status: spy(),
            set: spy(),
            json: spy()
          };

          returnValue = {};
          
          next = spy();

          checkEmptyPayload(req, res, next);
          expectedReturnValue = returnValue;
        });

        /*
        describe('should call res.status()', function () {
          it('once', function () {
            expect(res.status.calledOnce).to.be.true;
          });

          it('with the argument 400', function () {
            expect(res.status.calledWithExactly(400)).to.be.true;
          });
        });

        describe('should call res.set()', function () {
          it('once', function () {
            expect(res.set.calledOnce).to.be.true;
          });

          it('with the arguments "Content-Type" and "application/json"', function () {
            expect(res.set.calledWithExactly('Content-Type', 'application/json')).to.be.true;
          });
        });

        describe('should call res.json()', function () {
          it('once', function () {
            expect(res.json.calledOnce).to.be.true;
          });

          it('with the arguments "Content-Type" and "application/json"', function () {
            expect(res.json.calledWithExactly({ message: 'Payload should not be empty' })).to.be.true;
          });
        });
        */
        it('should not call next()', function () {
          expect(next.notCalled).to.be.true;
        });

        it('should return the value returned by `res.json()`', function () {
          expect(expectedReturnValue).to.be.equal(returnValue);
        });
      });
    });
  });
});
